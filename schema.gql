# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateRealmHistory {
  _avg: RealmHistoryAvgAggregate
  _count: RealmHistoryCountAggregate
  _max: RealmHistoryMaxAggregate
  _min: RealmHistoryMinAggregate
  _sum: RealmHistorySumAggregate
}

"""Army"""
type Army {
  arcanistHealth: Int!
  arcanistQty: Int!
  archerHealth: Int!
  archerQty: Int!
  armyId: Int!
  armyPacked: Int!
  callSign: Int!
  destinationArrivalTime: Timestamp
  destinationRealm: Realm
  destinationRealmId: Int!
  heavyCavalryHealth: Int!
  heavyCavalryQty: Int!
  heavyInfantryHealth: Int!
  heavyInfantryQty: Int!
  lastAttacked: Timestamp
  level: Int!
  lightCavalryHealth: Int!
  lightCavalryQty: Int!
  lightInfantryHealth: Int!
  lightInfantryQty: Int!
  longbowHealth: Int!
  longbowQty: Int!
  mageHealth: Int!
  mageQty: Int!
  realmId: Int!
  xp: Int!
}

input ArmyListRelationFilter {
  every: ArmyWhereInput
  none: ArmyWhereInput
  some: ArmyWhereInput
}

input ArmyOrderByRelationAggregateInput {
  _count: SortOrder
}

input ArmyOrderByWithRelationInput {
  arcanistHealth: SortOrder
  arcanistQty: SortOrder
  archerHealth: SortOrder
  archerQty: SortOrder
  armyId: SortOrder
  armyPacked: SortOrder
  callSign: SortOrder
  destinationArrivalTime: SortOrder
  destinationRealmId: SortOrder
  heavyCavalryHealth: SortOrder
  heavyCavalryQty: SortOrder
  heavyInfantryHealth: SortOrder
  heavyInfantryQty: SortOrder
  lastAttacked: SortOrder
  level: SortOrder
  lightCavalryHealth: SortOrder
  lightCavalryQty: SortOrder
  lightInfantryHealth: SortOrder
  lightInfantryQty: SortOrder
  longbowHealth: SortOrder
  longbowQty: SortOrder
  mageHealth: SortOrder
  mageQty: SortOrder
  ownRealm: RealmOrderByWithRelationInput
  realmId: SortOrder
  xp: SortOrder
}

input ArmyWhereInput {
  AND: [ArmyWhereInput!]
  NOT: [ArmyWhereInput!]
  OR: [ArmyWhereInput!]
  arcanistHealth: IntFilter
  arcanistQty: IntFilter
  archerHealth: IntFilter
  archerQty: IntFilter
  armyId: IntFilter
  armyPacked: IntFilter
  callSign: IntFilter
  destinationArrivalTime: DateTimeNullableFilter
  destinationRealmId: IntFilter
  heavyCavalryHealth: IntFilter
  heavyCavalryQty: IntFilter
  heavyInfantryHealth: IntFilter
  heavyInfantryQty: IntFilter
  lastAttacked: DateTimeNullableFilter
  level: IntFilter
  lightCavalryHealth: IntFilter
  lightCavalryQty: IntFilter
  lightInfantryHealth: IntFilter
  lightInfantryQty: IntFilter
  longbowHealth: IntFilter
  longbowQty: IntFilter
  mageHealth: IntFilter
  mageQty: IntFilter
  ownRealm: RealmRelationFilter
  realmId: IntFilter
  xp: IntFilter
}

"""Battalion Cost Model"""
type BattalionCost {
  amount: Float!
  battalionId: Int!
  battalionName: String!
  resources: JSON!
}

"""BattalionStats"""
type BattalionStats {
  battalionId: Int!
  battalionName: String!
  combatType: String!
  requiredBuildingId: Int!
  requiredBuildingName: String!
  type: String!
  value: Int!
}

"""The Buildings Model"""
type Building {
  buildingCost: BuildingCost!
  buildingId: Int!
  buildingIntegrity: Int!
  buildingName: String!
  builds: [String!]!
  count: Int!
  culture: Int!
  food: Int!
  limit: Float
  limitTraitId: Int!
  limitTraitName: String!
  population: Int!
  realmId: Float!
  size: Int!
}

"""Building Cost Model"""
type BuildingCost {
  amount: Float!
  buildingId: Int!
  buildingName: String!
  resources: JSON!
}

input BuildingListRelationFilter {
  every: BuildingWhereInput
  none: BuildingWhereInput
  some: BuildingWhereInput
}

input BuildingOrderByRelationAggregateInput {
  _count: SortOrder
}

input BuildingWhereInput {
  AND: [BuildingWhereInput!]
  NOT: [BuildingWhereInput!]
  OR: [BuildingWhereInput!]
  buildingId: IntFilter
  buildingIntegrity: IntFilter
  builds: StringNullableListFilter
  eventId: StringFilter
  id: IntFilter
  realm: RealmRelationFilter
  realmId: IntNullableFilter
}

"""The Combat History Model"""
type CombatHistory {
  attackRealmId: Int!
  attackRealmOwner: String
  attackSquad: JSON
  attackType: Int
  defendRealmId: Int!
  defendRealmOwner: String
  defendSquad: JSON
  eventId: String!
  eventType: String!
  hitPoints: Int
  id: Int!
  outcome: Int
  timestamp: Timestamp
  transactionHash: String
}

"""The CombatResult Model"""
type CombatResult {
  attackRealmId: Int!
  defendRealmId: Int!
  history: [CombatHistory!]
  outcome: Int
  relicLost: Int
  resourcesPillaged: [ResourceAmount!]
  timestamp: Timestamp
  transactionHash: String!
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input DateTimeNullableFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeNullableFilter
  notIn: [Timestamp!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

"""The Desiege Model"""
type Desiege {
  attackedTokens: Int!
  defendedTokens: Int!
  endBlock: Int!
  eventIndexed: Float!
  gameId: Int!
  id: ID!
  initialHealth: Int!
  startBlock: Int!
  startedOn: Timestamp!
  winner: Int!
}

input EnumOrderTypeNullableFilter {
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableFilter
  notIn: [OrderType!]
}

input EnumOrderTypeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumOrderTypeNullableFilter
  _min: NestedEnumOrderTypeNullableFilter
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableWithAggregatesFilter
  notIn: [OrderType!]
}

input EnumRealmTraitTypeFilter {
  equals: RealmTraitType
  in: [RealmTraitType!]
  not: NestedEnumRealmTraitTypeFilter
  notIn: [RealmTraitType!]
}

type ExchangeRate {
  amount: String!
  buyAmount: String!
  currencyReserve: String!
  date: String!
  hour: Int!
  lpAmount: String!
  sellAmount: String!
  tokenId: Int!
  tokenReserve: String!
}

"""Exchange Rate"""
type ExchangeRate24Hr {
  amount: String!
  buyAmount: String!
  currencyReserve: String!
  date: String!
  hour: Int!
  lpAmount: String!
  percentChange24Hr: Float
  sellAmount: String!
  tokenId: Int!
  tokenName: String!
  tokenReserve: String!
}

input ExchangeRateDateHourTokenIdCompoundUniqueInput {
  date: String!
  hour: Int!
  tokenId: Int!
}

input ExchangeRateOrderByWithRelationInput {
  amount: SortOrder
  buyAmount: SortOrder
  currencyReserve: SortOrder
  date: SortOrder
  hour: SortOrder
  lpAmount: SortOrder
  sellAmount: SortOrder
  tokenId: SortOrder
  tokenReserve: SortOrder
}

enum ExchangeRateScalarFieldEnum {
  amount
  buyAmount
  currencyReserve
  date
  hour
  lpAmount
  sellAmount
  tokenId
  tokenReserve
}

input ExchangeRateWhereInput {
  AND: [ExchangeRateWhereInput!]
  NOT: [ExchangeRateWhereInput!]
  OR: [ExchangeRateWhereInput!]
  amount: StringFilter
  buyAmount: StringFilter
  currencyReserve: StringFilter
  date: StringFilter
  hour: IntFilter
  lpAmount: StringFilter
  sellAmount: StringFilter
  tokenId: IntFilter
  tokenReserve: StringFilter
}

input ExchangeRateWhereUniqueInput {
  date_hour_tokenId: ExchangeRateDateHourTokenIdCompoundUniqueInput
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

"""The Food Model"""
type Food {
  buildingId: Int!
  buildingName: String!
  createdAt: Timestamp!
  harvests: Float
  qty: Float
  realmId: Float!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

"""Lore Entity"""
type LoreEntity {
  id: ID!
  kind: Float!
  owner: String!
  ownerDisplayName: String
  revisions: [LoreEntityRevision!]!
}

input LoreEntityRelationFilter {
  is: LoreEntityWhereInput
  isNot: LoreEntityWhereInput
}

"""Lore Entity Revision"""
type LoreEntityRevision {
  createdAt: Timestamp!
  excerpt: String
  id: ID!
  markdown: String
  pois: [LorePoisOnEntityRevisions!]!
  props: [LorePropsOnEntityRevisions!]!
  revisionNumber: Float!
  title: String
}

input LoreEntityRevisionListRelationFilter {
  every: LoreEntityRevisionWhereInput
  none: LoreEntityRevisionWhereInput
  some: LoreEntityRevisionWhereInput
}

input LoreEntityRevisionRelationFilter {
  is: LoreEntityRevisionWhereInput
  isNot: LoreEntityRevisionWhereInput
}

input LoreEntityRevisionWhereInput {
  AND: [LoreEntityRevisionWhereInput!]
  NOT: [LoreEntityRevisionWhereInput!]
  OR: [LoreEntityRevisionWhereInput!]
  arweaveId: StringFilter
  createdAt: DateTimeNullableFilter
  entity: LoreEntityRelationFilter
  entityId: IntFilter
  eventIndexed: StringNullableFilter
  excerpt: StringNullableFilter
  id: IntFilter
  markdown: StringNullableFilter
  media_url: StringNullableFilter
  pois: LorePoisOnEntityRevisionsListRelationFilter
  props: LorePropsOnEntityRevisionsListRelationFilter
  revisionNumber: IntFilter
  title: StringNullableFilter
}

input LoreEntityWhereInput {
  AND: [LoreEntityWhereInput!]
  NOT: [LoreEntityWhereInput!]
  OR: [LoreEntityWhereInput!]
  eventIndexed: StringNullableFilter
  id: IntFilter
  kind: IntFilter
  owner: StringNullableFilter
  ownerDisplayName: StringNullableFilter
  revisions: LoreEntityRevisionListRelationFilter
}

input LorePOIRelationFilter {
  is: LorePOIWhereInput
  isNot: LorePOIWhereInput
}

input LorePOIWhereInput {
  AND: [LorePOIWhereInput!]
  NOT: [LorePOIWhereInput!]
  OR: [LorePOIWhereInput!]
  assetType: StringNullableFilter
  entities: LorePoisOnEntityRevisionsListRelationFilter
  id: IntFilter
  name: StringFilter
}

"""Lore POI"""
type LorePoi {
  assetType: String
  id: ID!
  name: String!
}

"""Lore Entity Revision"""
type LorePoisOnEntityRevisions {
  assetId: String
  entityRevisionId: ID!
  poiId: ID!
}

input LorePoisOnEntityRevisionsListRelationFilter {
  every: LorePoisOnEntityRevisionsWhereInput
  none: LorePoisOnEntityRevisionsWhereInput
  some: LorePoisOnEntityRevisionsWhereInput
}

input LorePoisOnEntityRevisionsWhereInput {
  AND: [LorePoisOnEntityRevisionsWhereInput!]
  NOT: [LorePoisOnEntityRevisionsWhereInput!]
  OR: [LorePoisOnEntityRevisionsWhereInput!]
  assetId: StringNullableFilter
  entityRevision: LoreEntityRevisionRelationFilter
  entityRevisionId: IntFilter
  id: IntFilter
  poi: LorePOIRelationFilter
  poiId: IntFilter
}

input LorePropRelationFilter {
  is: LorePropWhereInput
  isNot: LorePropWhereInput
}

input LorePropWhereInput {
  AND: [LorePropWhereInput!]
  NOT: [LorePropWhereInput!]
  OR: [LorePropWhereInput!]
  entities: LorePropsOnEntityRevisionsListRelationFilter
  id: IntFilter
  name: StringFilter
}

"""Lore Entity Revision"""
type LorePropsOnEntityRevisions {
  entityRevisionId: ID!
  propId: ID!
  value: String
}

input LorePropsOnEntityRevisionsListRelationFilter {
  every: LorePropsOnEntityRevisionsWhereInput
  none: LorePropsOnEntityRevisionsWhereInput
  some: LorePropsOnEntityRevisionsWhereInput
}

input LorePropsOnEntityRevisionsWhereInput {
  AND: [LorePropsOnEntityRevisionsWhereInput!]
  NOT: [LorePropsOnEntityRevisionsWhereInput!]
  OR: [LorePropsOnEntityRevisionsWhereInput!]
  entityRevision: LoreEntityRevisionRelationFilter
  entityRevisionId: IntFilter
  id: IntFilter
  prop: LorePropRelationFilter
  propId: IntFilter
  value: StringNullableFilter
}

type Mutation {
  reindexDesiege: Boolean!
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedDateTimeNullableFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeNullableFilter
  notIn: [Timestamp!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input NestedEnumOrderTypeNullableFilter {
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableFilter
  notIn: [OrderType!]
}

input NestedEnumOrderTypeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumOrderTypeNullableFilter
  _min: NestedEnumOrderTypeNullableFilter
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableWithAggregatesFilter
  notIn: [OrderType!]
}

input NestedEnumRealmTraitTypeFilter {
  equals: RealmTraitType
  in: [RealmTraitType!]
  not: NestedEnumRealmTraitTypeFilter
  notIn: [RealmTraitType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""Order By Direction"""
enum OrderByDirectionInput {
  asc
  desc
}

enum OrderType {
  Anger
  Brilliance
  Detection
  Enlightenment
  Fury
  Giants
  Perfection
  Power
  Protection
  Rage
  Reflection
  Skill
  Titans
  Vitriol
  the_Fox
  the_Twins
}

type Query {
  aggregateRealmHistory(cursor: RealmHistoryWhereUniqueInput, orderBy: [RealmHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: RealmHistoryWhereInput): AggregateRealmHistory!
  armies(orderBy: ArmyOrderByWithRelationInput, skip: Float = 0, take: Float = 100, where: ArmyWhereInput): [Army!]!
  battalionCosts: [BattalionCost!]!
  battalionStats: [BattalionStats!]!
  exchangeRates(cursor: ExchangeRateWhereUniqueInput, distinct: [ExchangeRateScalarFieldEnum!], orderBy: [ExchangeRateOrderByWithRelationInput!], skip: Int, take: Int, where: ExchangeRateWhereInput): [ExchangeRate!]!
  getBuildingCostById: BuildingCost!
  getBuildingCosts: [BuildingCost!]!
  getBuildingsByRealmId(id: Float!): [Building!]!
  getDesiege(id: Float!): Desiege!
  getDesiegeCurrent: Desiege!
  getDesiegeGames: [Desiege!]!
  getExchangeRates: [ExchangeRate24Hr!]!
  getFoodByRealmId(id: Float!): [Food!]!
  getLoreEntities(filter: LoreEntityWhereInput, skip: Float = 0, take: Float = 100): [LoreEntity!]!
  getLoreEntity(entityId: Float!): LoreEntity!
  getLorePois(skip: Float = 0, take: Float = 100): [LorePoi!]!
  getRealm(realmId: Float!): Realm!
  getRealmCombatResult(defendRealmId: Float!, transactionHash: String!): CombatResult!
  getRealmHistory(filter: RealmHistoryWhereInput, skip: Float = 0, take: Float = 20): [RealmHistory!]!
  getRealms(filter: RealmWhereInput, orderBy: RealmOrderByInput, skip: Float = 0, take: Float = 100): [Realm!]!
  getResource(id: Float!): Resource!
  getResources: [Resource!]!
  getResourcesByAddress(address: String!): [Resource!]!
  getTroopStats: [TroopStats!]!
  getWallet(address: String!): Wallet!
  groupByRealmHistory(by: [RealmHistoryScalarFieldEnum!]!, having: RealmHistoryScalarWhereWithAggregatesInput, orderBy: [RealmHistoryOrderByWithAggregationInput!], skip: Int, take: Int, where: RealmHistoryWhereInput): [RealmHistoryGroupBy!]!
  realm(id: Float!): Realm!
  realmCombatHistory(defendRealmId: Float!, transactionHash: String!): CombatResult!
  realmHistory(filter: RealmHistoryWhereInput, skip: Float = 0, take: Float = 20): [RealmHistory!]!
  realms(filter: RealmWhereInput, orderBy: RealmOrderByWithRelationInput, skip: Float = 0, take: Float = 100): [Realm!]!
  realmsCount(filter: RealmWhereInput): Int!
  travels(cursor: TravelWhereUniqueInput, distinct: [TravelScalarFieldEnum!], orderBy: [TravelOrderByWithRelationInput!], skip: Int, take: Int, where: TravelWhereInput): [Travel!]!
  troopStats: [TroopStats!]!
}

enum QueryMode {
  default
  insensitive
}

"""The Realm Model"""
type Realm {
  bridgedOwner: String
  buildings: [Building!]
  defendTroopIds: [String!]!
  imageUrl: String
  lastAttacked: Timestamp
  lastClaimTime: Timestamp
  lastVaultTime: Timestamp
  latitude: Float!
  longitude: Float!
  name: String
  orderType: String!
  ownArmies: [Army!]!
  owner: String
  ownerL2: String
  rarityRank: Int!
  rarityScore: Float!
  realmId: Int!
  relic: [Relic!]
  relicsOwned: [Relic!]
  resources: [Resource!]
  settledOwner: String
  squad: [Troop!]
  traits: [RealmTrait!]
  troops: [Troop!]
  wallet: Wallet
  wonder: String
}

"""The Realm History Model"""
type RealmHistory {
  data: JSON
  eventId: String
  eventType: String
  id: Int!
  realm: Realm
  realmId: Int!
  realmName: String
  realmOrder: String
  realmOwner: String
  timestamp: Timestamp
  transactionHash: String
}

type RealmHistoryAvgAggregate {
  id: Float
  realmId: Float
}

input RealmHistoryAvgOrderByAggregateInput {
  id: SortOrder
  realmId: SortOrder
}

type RealmHistoryCountAggregate {
  _all: Int!
  data: Int!
  eventId: Int!
  eventType: Int!
  id: Int!
  realmId: Int!
  realmName: Int!
  realmOrder: Int!
  realmOwner: Int!
  timestamp: Int!
  transactionHash: Int!
}

input RealmHistoryCountOrderByAggregateInput {
  data: SortOrder
  eventId: SortOrder
  eventType: SortOrder
  id: SortOrder
  realmId: SortOrder
  realmName: SortOrder
  realmOrder: SortOrder
  realmOwner: SortOrder
  timestamp: SortOrder
  transactionHash: SortOrder
}

input RealmHistoryEventIdEventTypeCompoundUniqueInput {
  eventId: String!
  eventType: String!
}

type RealmHistoryGroupBy {
  _avg: RealmHistoryAvgAggregate
  _count: RealmHistoryCountAggregate
  _max: RealmHistoryMaxAggregate
  _min: RealmHistoryMinAggregate
  _sum: RealmHistorySumAggregate
  data: JSON!
  eventId: String!
  eventType: String!
  id: Int!
  realmId: Int!
  realmName: String!
  realmOrder: OrderType
  realmOwner: String!
  timestamp: Timestamp!
  transactionHash: String!
}

type RealmHistoryMaxAggregate {
  eventId: String
  eventType: String
  id: Int
  realmId: Int
  realmName: String
  realmOrder: OrderType
  realmOwner: String
  timestamp: Timestamp
  transactionHash: String
}

input RealmHistoryMaxOrderByAggregateInput {
  eventId: SortOrder
  eventType: SortOrder
  id: SortOrder
  realmId: SortOrder
  realmName: SortOrder
  realmOrder: SortOrder
  realmOwner: SortOrder
  timestamp: SortOrder
  transactionHash: SortOrder
}

type RealmHistoryMinAggregate {
  eventId: String
  eventType: String
  id: Int
  realmId: Int
  realmName: String
  realmOrder: OrderType
  realmOwner: String
  timestamp: Timestamp
  transactionHash: String
}

input RealmHistoryMinOrderByAggregateInput {
  eventId: SortOrder
  eventType: SortOrder
  id: SortOrder
  realmId: SortOrder
  realmName: SortOrder
  realmOrder: SortOrder
  realmOwner: SortOrder
  timestamp: SortOrder
  transactionHash: SortOrder
}

input RealmHistoryOrderByWithAggregationInput {
  _avg: RealmHistoryAvgOrderByAggregateInput
  _count: RealmHistoryCountOrderByAggregateInput
  _max: RealmHistoryMaxOrderByAggregateInput
  _min: RealmHistoryMinOrderByAggregateInput
  _sum: RealmHistorySumOrderByAggregateInput
  data: SortOrder
  eventId: SortOrder
  eventType: SortOrder
  id: SortOrder
  realmId: SortOrder
  realmName: SortOrder
  realmOrder: SortOrder
  realmOwner: SortOrder
  timestamp: SortOrder
  transactionHash: SortOrder
}

input RealmHistoryOrderByWithRelationInput {
  data: SortOrder
  eventId: SortOrder
  eventType: SortOrder
  id: SortOrder
  realmId: SortOrder
  realmName: SortOrder
  realmOrder: SortOrder
  realmOwner: SortOrder
  timestamp: SortOrder
  transactionHash: SortOrder
}

enum RealmHistoryScalarFieldEnum {
  data
  eventId
  eventType
  id
  realmId
  realmName
  realmOrder
  realmOwner
  timestamp
  transactionHash
}

input RealmHistoryScalarWhereWithAggregatesInput {
  AND: [RealmHistoryScalarWhereWithAggregatesInput!]
  NOT: [RealmHistoryScalarWhereWithAggregatesInput!]
  OR: [RealmHistoryScalarWhereWithAggregatesInput!]
  data: JsonWithAggregatesFilter
  eventId: StringWithAggregatesFilter
  eventType: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  realmId: IntWithAggregatesFilter
  realmName: StringWithAggregatesFilter
  realmOrder: EnumOrderTypeNullableWithAggregatesFilter
  realmOwner: StringWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
  transactionHash: StringWithAggregatesFilter
}

type RealmHistorySumAggregate {
  id: Int
  realmId: Int
}

input RealmHistorySumOrderByAggregateInput {
  id: SortOrder
  realmId: SortOrder
}

input RealmHistoryWhereInput {
  AND: [RealmHistoryWhereInput!]
  NOT: [RealmHistoryWhereInput!]
  OR: [RealmHistoryWhereInput!]
  data: JsonFilter
  eventId: StringFilter
  eventType: StringFilter
  id: IntFilter
  realmId: IntFilter
  realmName: StringFilter
  realmOrder: EnumOrderTypeNullableFilter
  realmOwner: StringFilter
  timestamp: DateTimeFilter
  transactionHash: StringFilter
}

input RealmHistoryWhereUniqueInput {
  eventId_eventType: RealmHistoryEventIdEventTypeCompoundUniqueInput
  id: Int
}

input RealmListRelationFilter {
  every: RealmWhereInput
  none: RealmWhereInput
  some: RealmWhereInput
}

input RealmOrderByInput {
  rarityRank: OrderByDirectionInput
  rarityScore: OrderByDirectionInput
  realmId: OrderByDirectionInput
}

input RealmOrderByRelationAggregateInput {
  _count: SortOrder
}

input RealmOrderByWithRelationInput {
  bridgedOwner: SortOrder
  buildings: BuildingOrderByRelationAggregateInput
  id: SortOrder
  imageUrl: SortOrder
  lastAttacked: SortOrder
  lastClaimTime: SortOrder
  lastVaultTime: SortOrder
  latitude: SortOrder
  longitude: SortOrder
  name: SortOrder
  orderType: SortOrder
  ownArmies: ArmyOrderByRelationAggregateInput
  owner: SortOrder
  ownerL2: SortOrder
  rarityRank: SortOrder
  rarityScore: SortOrder
  realmId: SortOrder
  relic: RelicOrderByWithRelationInput
  relicsOwned: RelicOrderByRelationAggregateInput
  resources: ResourceOrderByRelationAggregateInput
  settledOwner: SortOrder
  squad: TroopOrderByRelationAggregateInput
  traits: RealmTraitOrderByRelationAggregateInput
  wallet: WalletOrderByWithRelationInput
  wonder: SortOrder
}

input RealmRelationFilter {
  is: RealmWhereInput
  isNot: RealmWhereInput
}

"""Realm Trait Model"""
type RealmTrait {
  id: ID!
  qty: Float!
  realm: Realm
  realmId: Float!
  type: String!
}

input RealmTraitListRelationFilter {
  every: RealmTraitWhereInput
  none: RealmTraitWhereInput
  some: RealmTraitWhereInput
}

input RealmTraitOrderByRelationAggregateInput {
  _count: SortOrder
}

enum RealmTraitType {
  City
  Harbor
  Region
  River
}

input RealmTraitWhereInput {
  AND: [RealmTraitWhereInput!]
  NOT: [RealmTraitWhereInput!]
  OR: [RealmTraitWhereInput!]
  qty: IntFilter
  realm: RealmRelationFilter
  realmId: IntFilter
  type: EnumRealmTraitTypeFilter
}

input RealmWhereInput {
  AND: [RealmWhereInput!]
  NOT: [RealmWhereInput!]
  OR: [RealmWhereInput!]
  bridgedOwner: StringNullableFilter
  buildings: BuildingListRelationFilter
  id: IntFilter
  imageUrl: StringFilter
  lastAttacked: DateTimeNullableFilter
  lastClaimTime: DateTimeNullableFilter
  lastVaultTime: DateTimeNullableFilter
  latitude: FloatFilter
  longitude: FloatFilter
  name: StringNullableFilter
  orderType: EnumOrderTypeNullableFilter
  ownArmies: ArmyListRelationFilter
  owner: StringNullableFilter
  ownerL2: StringNullableFilter
  rarityRank: IntFilter
  rarityScore: FloatFilter
  realmId: IntFilter
  relic: RelicRelationFilter
  relicsOwned: RelicListRelationFilter
  resources: ResourceListRelationFilter
  settledOwner: StringNullableFilter
  squad: TroopListRelationFilter
  traits: RealmTraitListRelationFilter
  wallet: WalletRelationFilter
  wonder: StringNullableFilter
}

"""The Relic Model"""
type Relic {
  heldByRealm: Float
  originRealm: Realm!
  realmHolder: Realm!
  realmId: Float
}

input RelicListRelationFilter {
  every: RelicWhereInput
  none: RelicWhereInput
  some: RelicWhereInput
}

input RelicOrderByRelationAggregateInput {
  _count: SortOrder
}

input RelicOrderByWithRelationInput {
  heldByRealm: SortOrder
  originRealm: RealmOrderByWithRelationInput
  realmHolder: RealmOrderByWithRelationInput
  realmId: SortOrder
}

input RelicRelationFilter {
  is: RelicWhereInput
  isNot: RelicWhereInput
}

input RelicWhereInput {
  AND: [RelicWhereInput!]
  NOT: [RelicWhereInput!]
  OR: [RelicWhereInput!]
  heldByRealm: IntFilter
  originRealm: RealmRelationFilter
  realmHolder: RealmRelationFilter
  realmId: IntFilter
}

"""The Resource Model"""
type Resource {
  id: ID!
  level: Int!
  realm: Realm!
  realmId: Float
  resourceId: Int!
  resourceName: String!
  upgrades: [String!]!
}

"""The Token Amount Model"""
type ResourceAmount {
  amount: String!
  resourceId: Int!
  resourceName: String!
}

input ResourceListRelationFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

input ResourceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourceTokenListRelationFilter {
  every: ResourceTokenWhereInput
  none: ResourceTokenWhereInput
  some: ResourceTokenWhereInput
}

input ResourceTokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourceTokenWhereInput {
  AND: [ResourceTokenWhereInput!]
  NOT: [ResourceTokenWhereInput!]
  OR: [ResourceTokenWhereInput!]
  address: StringFilter
  id: IntFilter
  qty: IntFilter
  resourceId: IntFilter
  wallet: WalletRelationFilter
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  id: IntFilter
  level: IntFilter
  realm: RealmRelationFilter
  realmId: IntNullableFilter
  resourceId: IntFilter
  upgrades: StringNullableListFilter
}

input SRealmListRelationFilter {
  every: SRealmWhereInput
  none: SRealmWhereInput
  some: SRealmWhereInput
}

input SRealmOrderByRelationAggregateInput {
  _count: SortOrder
}

input SRealmWhereInput {
  AND: [SRealmWhereInput!]
  NOT: [SRealmWhereInput!]
  OR: [SRealmWhereInput!]
  id: IntFilter
  owner: StringNullableFilter
  realmId: IntFilter
  wallet: WalletRelationFilter
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type Travel {
  contractId: Int!
  destinationArrivalTime: Timestamp!
  destinationContractId: Int!
  destinationNestedId: Int!
  destinationRealm: Realm
  destinationTokenId: Int!
  eventId: String!
  nestedId: Int!
  originRealm: Realm
  timestamp: Timestamp!
  tokenId: Int!
}

input TravelOrderByWithRelationInput {
  contractId: SortOrder
  destinationArrivalTime: SortOrder
  destinationContractId: SortOrder
  destinationNestedId: SortOrder
  destinationTokenId: SortOrder
  eventId: SortOrder
  nestedId: SortOrder
  timestamp: SortOrder
  tokenId: SortOrder
}

enum TravelScalarFieldEnum {
  contractId
  destinationArrivalTime
  destinationContractId
  destinationNestedId
  destinationTokenId
  eventId
  nestedId
  timestamp
  tokenId
}

input TravelWhereInput {
  AND: [TravelWhereInput!]
  NOT: [TravelWhereInput!]
  OR: [TravelWhereInput!]
  contractId: IntFilter
  destinationArrivalTime: DateTimeFilter
  destinationContractId: IntFilter
  destinationNestedId: IntFilter
  destinationTokenId: IntFilter
  eventId: StringFilter
  nestedId: IntFilter
  timestamp: DateTimeFilter
  tokenId: IntFilter
}

input TravelWhereUniqueInput {
  eventId: String
}

"""Troop"""
type Troop {
  agility: Int!
  armor: Int!
  attack: Int!
  building: Int!
  index: Int!
  realmId: Int!
  squadSlot: Int!
  tier: Int!
  troopCost: TroopCost
  troopId: Int!
  troopName: String!
  type: Int!
  vitality: Int!
  wisdom: Int!
}

"""Troop Cost Model"""
type TroopCost {
  amount: Float!
  resources: JSON!
  troopId: Int!
  troopName: String!
}

input TroopListRelationFilter {
  every: TroopWhereInput
  none: TroopWhereInput
  some: TroopWhereInput
}

input TroopOrderByRelationAggregateInput {
  _count: SortOrder
}

"""TroopStats"""
type TroopStats {
  agility: Int!
  armor: Int!
  attack: Int!
  building: Int!
  tier: Int!
  troopCost: TroopCost
  troopId: Int!
  troopName: String!
  type: Int!
  vitality: Int!
  wisdom: Int!
}

input TroopWhereInput {
  AND: [TroopWhereInput!]
  NOT: [TroopWhereInput!]
  OR: [TroopWhereInput!]
  Realm: RealmRelationFilter
  agility: IntFilter
  armor: IntFilter
  attack: IntFilter
  building: IntFilter
  index: IntFilter
  realmId: IntFilter
  squadSlot: IntFilter
  tier: IntFilter
  timestamp: DateTimeNullableFilter
  troopId: IntFilter
  type: IntFilter
  vitality: IntFilter
  wisdom: IntFilter
}

"""The Wallet Model"""
type Wallet {
  address: String!
  realmsBridgedHeld: Int!
  realmsL1Held: Int!
  realmsL2Held: Int!
  realmsSettledHeld: Int!
}

input WalletOrderByWithRelationInput {
  address: SortOrder
  id: SortOrder
  realms: RealmOrderByRelationAggregateInput
  sRealms: SRealmOrderByRelationAggregateInput
  tokens: ResourceTokenOrderByRelationAggregateInput
}

input WalletRelationFilter {
  is: WalletWhereInput
  isNot: WalletWhereInput
}

input WalletWhereInput {
  AND: [WalletWhereInput!]
  NOT: [WalletWhereInput!]
  OR: [WalletWhereInput!]
  address: StringFilter
  id: IntFilter
  realms: RealmListRelationFilter
  sRealms: SRealmListRelationFilter
  tokens: ResourceTokenListRelationFilter
}
