# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateDesiege {
  _avg: DesiegeAvgAggregate
  _count: DesiegeCountAggregate
  _max: DesiegeMaxAggregate
  _min: DesiegeMinAggregate
  _sum: DesiegeSumAggregate
}

type AggregateEvent {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
}

"""The Buildings Model"""
type Building {
  id: ID!
  realm: Realm
  realmId: Float!
  type: String
}

"""Building Cost Model"""
type BuildingCost {
  buildingType: String!
  qty: Float!
  resourceType: String!
}

input BuildingCostInput {
  buildingType: String!
  qty: Float!
  resourceType: String!
}

input BuildingInput {
  id: ID
  realmId: Float!
  type: BuildingType!
}

enum BuildingType {
  Amphitheater
  Carpenter
  Castle
  Dock
  Explorers_Guild
  Fairgrounds
  Farms
  Fishmonger
  Granary
  Grand_Market
  Guild
  Hamlet
  Housing
  Logistics_Office
  Officer_Academy
  Parade_Grounds
  Resource_Facility
  Royal_Reserve
  School
  Symposium
}

input BuildingTypeInput {
  equals: BuildingType
  in: [BuildingType!]
  not: [BuildingType!]
  notIn: [BuildingType!]
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Desiege {
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int!
  id: Int!
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

type DesiegeAvgAggregate {
  attackedTokens: Float
  defendedTokens: Float
  gameId: Float
  id: Float
  initialHealth: Float
  winner: Float
}

input DesiegeAvgOrderByAggregateInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  winner: SortOrder
}

type DesiegeCountAggregate {
  _all: Int!
  attackedTokens: Int!
  defendedTokens: Int!
  eventIndexed: Int!
  gameId: Int!
  id: Int!
  initialHealth: Int!
  startedOn: Int!
  winner: Int!
}

input DesiegeCountOrderByAggregateInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  eventIndexed: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  startedOn: SortOrder
  winner: SortOrder
}

input DesiegeCreateInput {
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int!
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

input DesiegeCreateManyInput {
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int!
  id: Int
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

type DesiegeGroupBy {
  _avg: DesiegeAvgAggregate
  _count: DesiegeCountAggregate
  _max: DesiegeMaxAggregate
  _min: DesiegeMinAggregate
  _sum: DesiegeSumAggregate
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int!
  id: Int!
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

type DesiegeMaxAggregate {
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int
  id: Int
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

input DesiegeMaxOrderByAggregateInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  eventIndexed: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  startedOn: SortOrder
  winner: SortOrder
}

type DesiegeMinAggregate {
  attackedTokens: Int
  defendedTokens: Int
  eventIndexed: String
  gameId: Int
  id: Int
  initialHealth: Int
  startedOn: DateTime
  winner: Int
}

input DesiegeMinOrderByAggregateInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  eventIndexed: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  startedOn: SortOrder
  winner: SortOrder
}

input DesiegeOrderByWithAggregationInput {
  _avg: DesiegeAvgOrderByAggregateInput
  _count: DesiegeCountOrderByAggregateInput
  _max: DesiegeMaxOrderByAggregateInput
  _min: DesiegeMinOrderByAggregateInput
  _sum: DesiegeSumOrderByAggregateInput
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  eventIndexed: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  startedOn: SortOrder
  winner: SortOrder
}

input DesiegeOrderByWithRelationInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  eventIndexed: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  startedOn: SortOrder
  winner: SortOrder
}

enum DesiegeScalarFieldEnum {
  attackedTokens
  defendedTokens
  eventIndexed
  gameId
  id
  initialHealth
  startedOn
  winner
}

input DesiegeScalarWhereWithAggregatesInput {
  AND: [DesiegeScalarWhereWithAggregatesInput!]
  NOT: [DesiegeScalarWhereWithAggregatesInput!]
  OR: [DesiegeScalarWhereWithAggregatesInput!]
  attackedTokens: IntNullableWithAggregatesFilter
  defendedTokens: IntNullableWithAggregatesFilter
  eventIndexed: StringNullableWithAggregatesFilter
  gameId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  initialHealth: IntNullableWithAggregatesFilter
  startedOn: DateTimeNullableWithAggregatesFilter
  winner: IntNullableWithAggregatesFilter
}

type DesiegeSumAggregate {
  attackedTokens: Int
  defendedTokens: Int
  gameId: Int
  id: Int
  initialHealth: Int
  winner: Int
}

input DesiegeSumOrderByAggregateInput {
  attackedTokens: SortOrder
  defendedTokens: SortOrder
  gameId: SortOrder
  id: SortOrder
  initialHealth: SortOrder
  winner: SortOrder
}

input DesiegeUpdateInput {
  attackedTokens: NullableIntFieldUpdateOperationsInput
  defendedTokens: NullableIntFieldUpdateOperationsInput
  eventIndexed: NullableStringFieldUpdateOperationsInput
  gameId: IntFieldUpdateOperationsInput
  initialHealth: NullableIntFieldUpdateOperationsInput
  startedOn: NullableDateTimeFieldUpdateOperationsInput
  winner: NullableIntFieldUpdateOperationsInput
}

input DesiegeUpdateManyMutationInput {
  attackedTokens: NullableIntFieldUpdateOperationsInput
  defendedTokens: NullableIntFieldUpdateOperationsInput
  eventIndexed: NullableStringFieldUpdateOperationsInput
  gameId: IntFieldUpdateOperationsInput
  initialHealth: NullableIntFieldUpdateOperationsInput
  startedOn: NullableDateTimeFieldUpdateOperationsInput
  winner: NullableIntFieldUpdateOperationsInput
}

input DesiegeWhereInput {
  AND: [DesiegeWhereInput!]
  NOT: [DesiegeWhereInput!]
  OR: [DesiegeWhereInput!]
  attackedTokens: IntNullableFilter
  defendedTokens: IntNullableFilter
  eventIndexed: StringNullableFilter
  gameId: IntFilter
  id: IntFilter
  initialHealth: IntNullableFilter
  startedOn: DateTimeNullableFilter
  winner: IntNullableFilter
}

input DesiegeWhereUniqueInput {
  gameId: Int
  id: Int
}

type Event {
  blockNumber: Int!
  chainId: String!
  contract: String!
  eventId: String!
  id: Int!
  name: String!
  parameters: [Int!]!
  status: Int!
  timestamp: DateTime!
  transactionNumber: Int!
  txHash: String!
}

type EventAvgAggregate {
  blockNumber: Float
  id: Float
  parameters: Float
  status: Float
  transactionNumber: Float
}

input EventAvgOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  parameters: SortOrder
  status: SortOrder
  transactionNumber: SortOrder
}

type EventCountAggregate {
  _all: Int!
  blockNumber: Int!
  chainId: Int!
  contract: Int!
  eventId: Int!
  id: Int!
  name: Int!
  parameters: Int!
  status: Int!
  timestamp: Int!
  transactionNumber: Int!
  txHash: Int!
}

input EventCountOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventCreateInput {
  blockNumber: Int
  chainId: String!
  contract: String!
  eventId: String!
  name: String!
  parameters: EventCreateparametersInput
  status: Int
  timestamp: DateTime!
  transactionNumber: Int
  txHash: String!
}

input EventCreateManyInput {
  blockNumber: Int
  chainId: String!
  contract: String!
  eventId: String!
  id: Int
  name: String!
  parameters: EventCreateparametersInput
  status: Int
  timestamp: DateTime!
  transactionNumber: Int
  txHash: String!
}

input EventCreateparametersInput {
  set: [Int!]!
}

type EventGroupBy {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
  blockNumber: Int!
  chainId: String!
  contract: String!
  eventId: String!
  id: Int!
  name: String!
  parameters: [Int!]
  status: Int!
  timestamp: DateTime!
  transactionNumber: Int!
  txHash: String!
}

type EventMaxAggregate {
  blockNumber: Int
  chainId: String
  contract: String
  eventId: String
  id: Int
  name: String
  status: Int
  timestamp: DateTime
  transactionNumber: Int
  txHash: String
}

input EventMaxOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

type EventMinAggregate {
  blockNumber: Int
  chainId: String
  contract: String
  eventId: String
  id: Int
  name: String
  status: Int
  timestamp: DateTime
  transactionNumber: Int
  txHash: String
}

input EventMinOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventOrderByWithAggregationInput {
  _avg: EventAvgOrderByAggregateInput
  _count: EventCountOrderByAggregateInput
  _max: EventMaxOrderByAggregateInput
  _min: EventMinOrderByAggregateInput
  _sum: EventSumOrderByAggregateInput
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventOrderByWithRelationInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

enum EventScalarFieldEnum {
  blockNumber
  chainId
  contract
  eventId
  id
  name
  parameters
  status
  timestamp
  transactionNumber
  txHash
}

input EventScalarWhereWithAggregatesInput {
  AND: [EventScalarWhereWithAggregatesInput!]
  NOT: [EventScalarWhereWithAggregatesInput!]
  OR: [EventScalarWhereWithAggregatesInput!]
  blockNumber: IntWithAggregatesFilter
  chainId: StringWithAggregatesFilter
  contract: StringWithAggregatesFilter
  eventId: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  parameters: IntNullableListFilter
  status: IntWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
  transactionNumber: IntWithAggregatesFilter
  txHash: StringWithAggregatesFilter
}

type EventSumAggregate {
  blockNumber: Int
  id: Int
  parameters: [Int!]
  status: Int
  transactionNumber: Int
}

input EventSumOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  parameters: SortOrder
  status: SortOrder
  transactionNumber: SortOrder
}

input EventUpdateInput {
  blockNumber: IntFieldUpdateOperationsInput
  chainId: StringFieldUpdateOperationsInput
  contract: StringFieldUpdateOperationsInput
  eventId: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parameters: EventUpdateparametersInput
  status: IntFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  transactionNumber: IntFieldUpdateOperationsInput
  txHash: StringFieldUpdateOperationsInput
}

input EventUpdateManyMutationInput {
  blockNumber: IntFieldUpdateOperationsInput
  chainId: StringFieldUpdateOperationsInput
  contract: StringFieldUpdateOperationsInput
  eventId: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parameters: EventUpdateparametersInput
  status: IntFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  transactionNumber: IntFieldUpdateOperationsInput
  txHash: StringFieldUpdateOperationsInput
}

input EventUpdateparametersInput {
  push: [Int!]
  set: [Int!]
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  chainId: StringFilter
  contract: StringFilter
  eventId: StringFilter
  id: IntFilter
  name: StringFilter
  parameters: IntNullableListFilter
  status: IntFilter
  timestamp: DateTimeFilter
  transactionNumber: IntFilter
  txHash: StringFilter
}

input EventWhereUniqueInput {
  eventId: String
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntFilterInput {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
  has: Int
  hasEvery: [Int!]
  hasSome: [Int!]
  isEmpty: Boolean
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createDesiege(data: DesiegeCreateInput!): Desiege!
  createEvent(data: EventCreateInput!): Event!
  createManyDesiege(data: [DesiegeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEvent(data: [EventCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOrUpdateBuildingCost(data: BuildingCostInput!): BuildingCost!
  createOrUpdateBuildings(data: BuildingInput!): Building!
  createOrUpdateRealm(data: RealmInput!): Realm!
  createOrUpdateRealmTrait(data: RealmTraitInput!): RealmTrait!
  createOrUpdateResources(data: ResourceInput!): Resource!
  createOrUpdateWallet(data: WalletInput!): Wallet!
  deleteDesiege(where: DesiegeWhereUniqueInput!): Desiege
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyDesiege(where: DesiegeWhereInput): AffectedRowsOutput!
  deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
  updateDesiege(data: DesiegeUpdateInput!, where: DesiegeWhereUniqueInput!): Desiege
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyDesiege(data: DesiegeUpdateManyMutationInput!, where: DesiegeWhereInput): AffectedRowsOutput!
  updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): AffectedRowsOutput!
  upsertDesiege(create: DesiegeCreateInput!, update: DesiegeUpdateInput!, where: DesiegeWhereUniqueInput!): Desiege!
  upsertEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

"""Order By Direction"""
enum OrderByDirectionInput {
  asc
  desc
}

enum OrderType {
  Anger
  Brilliance
  Detection
  Enlightenment
  Fury
  Giants
  Perfection
  Power
  Protection
  Rage
  Reflection
  Skill
  Titans
  Vitriol
  the_Fox
  the_Twins
}

input OrderTypeInput {
  equals: OrderType
  in: [OrderType!]
  not: [OrderType!]
  notIn: [OrderType!]
}

type Query {
  aggregateDesiege(cursor: DesiegeWhereUniqueInput, orderBy: [DesiegeOrderByWithRelationInput!], skip: Int, take: Int, where: DesiegeWhereInput): AggregateDesiege!
  aggregateEvent(cursor: EventWhereUniqueInput, orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): AggregateEvent!
  desiege(where: DesiegeWhereUniqueInput!): Desiege
  desieges(cursor: DesiegeWhereUniqueInput, distinct: [DesiegeScalarFieldEnum!], orderBy: [DesiegeOrderByWithRelationInput!], skip: Int, take: Int, where: DesiegeWhereInput): [Desiege!]!
  event(where: EventWhereUniqueInput!): Event
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  findFirstDesiege(cursor: DesiegeWhereUniqueInput, distinct: [DesiegeScalarFieldEnum!], orderBy: [DesiegeOrderByWithRelationInput!], skip: Int, take: Int, where: DesiegeWhereInput): Desiege
  findFirstEvent(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): Event
  getBuilding(id: Float!): Building!
  getBuildingCosts: [BuildingCost!]!
  getBuildings: [Building!]!
  getBuildingsByAddress(address: String!): [Building!]!
  getBuildingsByRealm(realmId: Float!): [Building!]!
  getRealm(realmId: Float!): Realm!
  getRealmTraits: [RealmTrait!]!
  getRealms(filter: RealmFilterInput, orderBy: RealmOrderByInput, skip: Float = 0, take: Float = 100): [Realm!]!
  getResource(id: Float!): Resource!
  getResources: [Resource!]!
  getResourcesByAddress(address: String!): [Resource!]!
  getWallet(address: String!): Wallet!
  getWallets: [Wallet!]!
  groupByDesiege(by: [DesiegeScalarFieldEnum!]!, having: DesiegeScalarWhereWithAggregatesInput, orderBy: [DesiegeOrderByWithAggregationInput!], skip: Int, take: Int, where: DesiegeWhereInput): [DesiegeGroupBy!]!
  groupByEvent(by: [EventScalarFieldEnum!]!, having: EventScalarWhereWithAggregatesInput, orderBy: [EventOrderByWithAggregationInput!], skip: Int, take: Int, where: EventWhereInput): [EventGroupBy!]!
}

enum QueryMode {
  default
  insensitive
}

"""The Realm Model"""
type Realm {
  bridgedOwner: String
  buildings: [Building!]
  imageUrl: String
  name: String
  orderType: String!
  owner: String
  rarityRank: Int!
  rarityScore: Float!
  realmId: Int!
  resources: [Resource!]
  squads: [Squad!]
  traits: [RealmTrait!]
  wallet: Wallet
  wonder: String
}

input RealmFilterInput {
  AND: [RealmFilterInput!]
  NOT: [RealmFilterInput!]
  OR: [RealmFilterInput!]
  bridgedOwner: StringFilterInput
  buildingType: BuildingTypeInput
  name: StringFilterInput
  orderType: OrderTypeInput
  owner: StringFilterInput
  rarityRank: IntFilterInput
  rarityScore: IntFilterInput
  realmId: IntFilterInput
  resourceType: ResourceTypeInput
  squadAction: SquadActionInput
  squadType: SquadTypeInput
  trait: RealmTraitFilterInput
  wonder: StringFilterInput
}

input RealmInput {
  bridgedOwner: String
  imageUrl: String
  name: String!
  orderType: String
  owner: String
  rarityRank: Int
  rarityScore: Float
  realmId: Int!
  wonder: String
}

input RealmOrderByInput {
  rarityRank: OrderByDirectionInput
  rarityScore: OrderByDirectionInput
  realmId: OrderByDirectionInput
}

"""Realm Trait Model"""
type RealmTrait {
  id: ID!
  qty: Float!
  realm: Realm
  realmId: Float!
  type: String!
}

input RealmTraitFilterInput {
  qty: IntFilterInput
  type: RealmTraitType!
}

input RealmTraitInput {
  qty: Float!
  realmId: Float!
  type: RealmTraitType!
}

enum RealmTraitType {
  City
  Harbor
  Region
  River
}

"""The Resource Model"""
type Resource {
  id: ID!
  realm: Realm!
  realmId: Float
  type: String!
}

input ResourceInput {
  id: ID
  realmId: Float!
  type: ResourceType!
}

"""ResourceType"""
enum ResourceType {
  Adamantine
  Alchemical_Silver
  Coal
  Cold_Iron
  Copper
  Deep_Crystal
  Diamonds
  Dragonhide
  Ethereal_Silica
  Gold
  Hartwood
  Ignium
  Ironwood
  Mithral
  Obsidian
  Ruby
  Sapphire
  Silver
  Stone
  True_Ice
  Twilight_Quartz
  Wood
}

input ResourceTypeInput {
  equals: ResourceType
  in: [ResourceType!]
  not: [ResourceType!]
  notIn: [ResourceType!]
}

enum SortOrder {
  asc
  desc
}

"""The Squad Model"""
type Squad {
  action: String!
  realm: Realm
  realmId: Int!
  type: String!
}

enum SquadAction {
  Defence
  Offence
}

input SquadActionInput {
  equals: SquadAction
  in: [SquadAction!]
  not: [SquadAction!]
  notIn: [SquadAction!]
}

enum SquadType {
  Apprentice
  Arcanist
  Archer
  Ballista
  Catapult
  Grand_Marshal
  Guard
  Guard_Captain
  Healer
  Knight
  Knight_Commander
  Life_Mage
  Mage
  Scorpio
  Scout
  Shaman
  Sniper
  Squire
  Watchman
}

input SquadTypeInput {
  equals: SquadType
  in: [SquadType!]
  not: [SquadType!]
  notIn: [SquadType!]
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringFilterInput {
  contains: [String!]
  endsWith: [String!]
  equals: String
  gt: [String!]
  gte: [String!]
  in: [String!]
  lt: [String!]
  lte: [String!]
  not: [String!]
  notIn: [String!]
  startsWith: [String!]
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""The Wallet Model"""
type Wallet {
  address: String!
  id: ID!
  realms: [Realm!]!
}

input WalletInput {
  address: String!
  realms: RealmInput
}
