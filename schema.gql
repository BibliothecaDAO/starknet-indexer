# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateEvent {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
}

"""The Buildings Model"""
type Building {
  buildingId: Int
  id: ID!
  realm: Realm
  realmId: Float!
}

"""Building Cost Model"""
type BuildingCost {
  buildingId: Int!
  qty: Float!
  resourceId: Int!
}

input BuildingListRelationFilter {
  every: BuildingWhereInput
  none: BuildingWhereInput
  some: BuildingWhereInput
}

input BuildingWhereInput {
  AND: [BuildingWhereInput!]
  NOT: [BuildingWhereInput!]
  OR: [BuildingWhereInput!]
  buildingId: IntFilter
  eventId: StringFilter
  id: IntFilter
  realm: RealmRelationFilter
  realmId: IntNullableFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""The Desiege Model"""
type Desiege {
  attackedTokens: Int!
  defendedTokens: Int!
  endBlock: Int!
  eventIndexed: Float!
  gameId: Int!
  id: ID!
  initialHealth: Int!
  startBlock: Int!
  startedOn: DateTime!
  winner: Int!
}

input EnumOrderTypeNullableFilter {
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableFilter
  notIn: [OrderType!]
}

input EnumRealmTraitTypeFilter {
  equals: RealmTraitType
  in: [RealmTraitType!]
  not: NestedEnumRealmTraitTypeFilter
  notIn: [RealmTraitType!]
}

type Event {
  blockNumber: Int!
  chainId: String!
  contract: String!
  eventId: String!
  id: Int!
  keys: [String!]!
  name: String!
  parameters: [String!]!
  status: Int!
  timestamp: DateTime!
  transactionNumber: Int!
  txHash: String!
}

type EventAvgAggregate {
  blockNumber: Float
  id: Float
  status: Float
  transactionNumber: Float
}

input EventAvgOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  status: SortOrder
  transactionNumber: SortOrder
}

type EventCountAggregate {
  _all: Int!
  blockNumber: Int!
  chainId: Int!
  contract: Int!
  eventId: Int!
  id: Int!
  keys: Int!
  name: Int!
  parameters: Int!
  status: Int!
  timestamp: Int!
  transactionNumber: Int!
  txHash: Int!
}

input EventCountOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  keys: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventCreateInput {
  blockNumber: Int
  chainId: String!
  contract: String!
  eventId: String!
  keys: EventCreatekeysInput
  name: String!
  parameters: EventCreateparametersInput
  status: Int
  timestamp: DateTime!
  transactionNumber: Int
  txHash: String!
}

input EventCreateManyInput {
  blockNumber: Int
  chainId: String!
  contract: String!
  eventId: String!
  id: Int
  keys: EventCreatekeysInput
  name: String!
  parameters: EventCreateparametersInput
  status: Int
  timestamp: DateTime!
  transactionNumber: Int
  txHash: String!
}

input EventCreatekeysInput {
  set: [String!]!
}

input EventCreateparametersInput {
  set: [String!]!
}

type EventGroupBy {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
  blockNumber: Int!
  chainId: String!
  contract: String!
  eventId: String!
  id: Int!
  keys: [String!]
  name: String!
  parameters: [String!]
  status: Int!
  timestamp: DateTime!
  transactionNumber: Int!
  txHash: String!
}

type EventMaxAggregate {
  blockNumber: Int
  chainId: String
  contract: String
  eventId: String
  id: Int
  name: String
  status: Int
  timestamp: DateTime
  transactionNumber: Int
  txHash: String
}

input EventMaxOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

type EventMinAggregate {
  blockNumber: Int
  chainId: String
  contract: String
  eventId: String
  id: Int
  name: String
  status: Int
  timestamp: DateTime
  transactionNumber: Int
  txHash: String
}

input EventMinOrderByAggregateInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventOrderByWithAggregationInput {
  _avg: EventAvgOrderByAggregateInput
  _count: EventCountOrderByAggregateInput
  _max: EventMaxOrderByAggregateInput
  _min: EventMinOrderByAggregateInput
  _sum: EventSumOrderByAggregateInput
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  keys: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

input EventOrderByWithRelationInput {
  blockNumber: SortOrder
  chainId: SortOrder
  contract: SortOrder
  eventId: SortOrder
  id: SortOrder
  keys: SortOrder
  name: SortOrder
  parameters: SortOrder
  status: SortOrder
  timestamp: SortOrder
  transactionNumber: SortOrder
  txHash: SortOrder
}

enum EventScalarFieldEnum {
  blockNumber
  chainId
  contract
  eventId
  id
  keys
  name
  parameters
  status
  timestamp
  transactionNumber
  txHash
}

input EventScalarWhereWithAggregatesInput {
  AND: [EventScalarWhereWithAggregatesInput!]
  NOT: [EventScalarWhereWithAggregatesInput!]
  OR: [EventScalarWhereWithAggregatesInput!]
  blockNumber: IntWithAggregatesFilter
  chainId: StringWithAggregatesFilter
  contract: StringWithAggregatesFilter
  eventId: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  keys: StringNullableListFilter
  name: StringWithAggregatesFilter
  parameters: StringNullableListFilter
  status: IntWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
  transactionNumber: IntWithAggregatesFilter
  txHash: StringWithAggregatesFilter
}

type EventSumAggregate {
  blockNumber: Int
  id: Int
  status: Int
  transactionNumber: Int
}

input EventSumOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  status: SortOrder
  transactionNumber: SortOrder
}

input EventUpdateInput {
  blockNumber: IntFieldUpdateOperationsInput
  chainId: StringFieldUpdateOperationsInput
  contract: StringFieldUpdateOperationsInput
  eventId: StringFieldUpdateOperationsInput
  keys: EventUpdatekeysInput
  name: StringFieldUpdateOperationsInput
  parameters: EventUpdateparametersInput
  status: IntFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  transactionNumber: IntFieldUpdateOperationsInput
  txHash: StringFieldUpdateOperationsInput
}

input EventUpdateManyMutationInput {
  blockNumber: IntFieldUpdateOperationsInput
  chainId: StringFieldUpdateOperationsInput
  contract: StringFieldUpdateOperationsInput
  eventId: StringFieldUpdateOperationsInput
  keys: EventUpdatekeysInput
  name: StringFieldUpdateOperationsInput
  parameters: EventUpdateparametersInput
  status: IntFieldUpdateOperationsInput
  timestamp: DateTimeFieldUpdateOperationsInput
  transactionNumber: IntFieldUpdateOperationsInput
  txHash: StringFieldUpdateOperationsInput
}

input EventUpdatekeysInput {
  push: [String!]
  set: [String!]
}

input EventUpdateparametersInput {
  push: [String!]
  set: [String!]
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  chainId: StringFilter
  contract: StringFilter
  eventId: StringFilter
  id: IntFilter
  keys: StringNullableListFilter
  name: StringFilter
  parameters: StringNullableListFilter
  status: IntFilter
  timestamp: DateTimeFilter
  transactionNumber: IntFilter
  txHash: StringFilter
}

input EventWhereUniqueInput {
  eventId: String
  id: Int
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""Lore Entity"""
type LoreEntity {
  id: ID!
  kind: Float!
  owner: String!
  revisions: [LoreEntityRevision!]!
}

input LoreEntityRelationFilter {
  is: LoreEntityWhereInput
  isNot: LoreEntityWhereInput
}

"""Lore Entity Revision"""
type LoreEntityRevision {
  createdAt: DateTime!
  excerpt: String
  id: ID!
  markdown: String
  pois: [LorePoisOnEntityRevisions!]!
  props: [LorePropsOnEntityRevisions!]!
  revisionNumber: Float!
  title: String
}

input LoreEntityRevisionListRelationFilter {
  every: LoreEntityRevisionWhereInput
  none: LoreEntityRevisionWhereInput
  some: LoreEntityRevisionWhereInput
}

input LoreEntityRevisionRelationFilter {
  is: LoreEntityRevisionWhereInput
  isNot: LoreEntityRevisionWhereInput
}

input LoreEntityRevisionWhereInput {
  AND: [LoreEntityRevisionWhereInput!]
  NOT: [LoreEntityRevisionWhereInput!]
  OR: [LoreEntityRevisionWhereInput!]
  arweaveId: StringFilter
  createdAt: DateTimeNullableFilter
  entity: LoreEntityRelationFilter
  entityId: IntFilter
  eventIndexed: StringNullableFilter
  excerpt: StringNullableFilter
  id: IntFilter
  markdown: StringNullableFilter
  media_url: StringNullableFilter
  pois: LorePoisOnEntityRevisionsListRelationFilter
  props: LorePropsOnEntityRevisionsListRelationFilter
  revisionNumber: IntFilter
  title: StringNullableFilter
}

input LoreEntityWhereInput {
  AND: [LoreEntityWhereInput!]
  NOT: [LoreEntityWhereInput!]
  OR: [LoreEntityWhereInput!]
  eventIndexed: StringNullableFilter
  id: IntFilter
  kind: IntFilter
  owner: StringNullableFilter
  revisions: LoreEntityRevisionListRelationFilter
}

input LorePOIRelationFilter {
  is: LorePOIWhereInput
  isNot: LorePOIWhereInput
}

input LorePOIWhereInput {
  AND: [LorePOIWhereInput!]
  NOT: [LorePOIWhereInput!]
  OR: [LorePOIWhereInput!]
  assetType: StringNullableFilter
  entities: LorePoisOnEntityRevisionsListRelationFilter
  id: IntFilter
  name: StringFilter
}

"""Lore POI"""
type LorePoi {
  assetType: String
  id: ID!
  name: String!
}

"""Lore Entity Revision"""
type LorePoisOnEntityRevisions {
  assetId: String
  entityRevisionId: ID!
  poiId: ID!
}

input LorePoisOnEntityRevisionsListRelationFilter {
  every: LorePoisOnEntityRevisionsWhereInput
  none: LorePoisOnEntityRevisionsWhereInput
  some: LorePoisOnEntityRevisionsWhereInput
}

input LorePoisOnEntityRevisionsWhereInput {
  AND: [LorePoisOnEntityRevisionsWhereInput!]
  NOT: [LorePoisOnEntityRevisionsWhereInput!]
  OR: [LorePoisOnEntityRevisionsWhereInput!]
  assetId: StringNullableFilter
  entityRevision: LoreEntityRevisionRelationFilter
  entityRevisionId: IntFilter
  poi: LorePOIRelationFilter
  poiId: IntFilter
}

input LorePropRelationFilter {
  is: LorePropWhereInput
  isNot: LorePropWhereInput
}

input LorePropWhereInput {
  AND: [LorePropWhereInput!]
  NOT: [LorePropWhereInput!]
  OR: [LorePropWhereInput!]
  entities: LorePropsOnEntityRevisionsListRelationFilter
  id: IntFilter
  name: StringFilter
}

"""Lore Entity Revision"""
type LorePropsOnEntityRevisions {
  entityRevisionId: ID!
  propId: ID!
  value: String
}

input LorePropsOnEntityRevisionsListRelationFilter {
  every: LorePropsOnEntityRevisionsWhereInput
  none: LorePropsOnEntityRevisionsWhereInput
  some: LorePropsOnEntityRevisionsWhereInput
}

input LorePropsOnEntityRevisionsWhereInput {
  AND: [LorePropsOnEntityRevisionsWhereInput!]
  NOT: [LorePropsOnEntityRevisionsWhereInput!]
  OR: [LorePropsOnEntityRevisionsWhereInput!]
  entityRevision: LoreEntityRevisionRelationFilter
  entityRevisionId: IntFilter
  prop: LorePropRelationFilter
  propId: IntFilter
  value: StringNullableFilter
}

type Mutation {
  createEvent(data: EventCreateInput!): Event!
  createManyEvent(data: [EventCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOrUpdateRealm(data: RealmInput!): Realm!
  createOrUpdateResources(data: ResourceInput!): Resource!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
  reindexDesiege: Boolean!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): AffectedRowsOutput!
  upsertEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumOrderTypeNullableFilter {
  equals: OrderType
  in: [OrderType!]
  not: NestedEnumOrderTypeNullableFilter
  notIn: [OrderType!]
}

input NestedEnumRealmTraitTypeFilter {
  equals: RealmTraitType
  in: [RealmTraitType!]
  not: NestedEnumRealmTraitTypeFilter
  notIn: [RealmTraitType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""Order By Direction"""
enum OrderByDirectionInput {
  asc
  desc
}

enum OrderType {
  Anger
  Brilliance
  Detection
  Enlightenment
  Fury
  Giants
  Perfection
  Power
  Protection
  Rage
  Reflection
  Skill
  Titans
  Vitriol
  the_Fox
  the_Twins
}

type Query {
  aggregateEvent(cursor: EventWhereUniqueInput, orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): AggregateEvent!
  event(where: EventWhereUniqueInput!): Event
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  findFirstEvent(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): Event
  getBuilding(id: Float!): Building!
  getBuildingCosts: [BuildingCost!]!
  getBuildings: [Building!]!
  getBuildingsByAddress(address: String!): [Building!]!
  getBuildingsByRealm(realmId: Float!): [Building!]!
  getDesiege(id: Float!): Desiege!
  getDesiegeCurrent: Desiege!
  getDesiegeGames: [Desiege!]!
  getLoreEntities(filter: LoreEntityWhereInput, skip: Float = 0, take: Float = 100): [LoreEntity!]!
  getLoreEntity(entityId: Float!): LoreEntity!
  getLorePois(skip: Float = 0, take: Float = 100): [LorePoi!]!
  getRealm(realmId: Float!): Realm!
  getRealms(filter: RealmWhereInput, orderBy: RealmOrderByInput, skip: Float = 0, take: Float = 100): [Realm!]!
  getResource(id: Float!): Resource!
  getResources: [Resource!]!
  getResourcesByAddress(address: String!): [Resource!]!
  getWallet(address: String!): Wallet!
  groupByEvent(by: [EventScalarFieldEnum!]!, having: EventScalarWhereWithAggregatesInput, orderBy: [EventOrderByWithAggregationInput!], skip: Int, take: Int, where: EventWhereInput): [EventGroupBy!]!
}

enum QueryMode {
  default
  insensitive
}

"""The Realm Model"""
type Realm {
  attackTroopIds: [String!]!
  bridgedOwner: String
  buildings: [Building!]
  defendTroopIds: [String!]!
  imageUrl: String
  name: String
  orderType: String!
  owner: String
  ownerL2: String
  rarityRank: Int!
  rarityScore: Float!
  realmId: Int!
  resources: [Resource!]
  settledOwner: String
  traits: [RealmTrait!]
  wallet: Wallet
  wonder: String
}

input RealmInput {
  bridgedOwner: String
  imageUrl: String
  name: String!
  orderType: String
  owner: String
  ownerL2: String
  rarityRank: Int
  rarityScore: Float
  realmId: Int!
  settledOwner: String
  wonder: String
}

input RealmListRelationFilter {
  every: RealmWhereInput
  none: RealmWhereInput
  some: RealmWhereInput
}

input RealmOrderByInput {
  rarityRank: OrderByDirectionInput
  rarityScore: OrderByDirectionInput
  realmId: OrderByDirectionInput
}

input RealmRelationFilter {
  is: RealmWhereInput
  isNot: RealmWhereInput
}

"""Realm Trait Model"""
type RealmTrait {
  id: ID!
  qty: Float!
  realm: Realm
  realmId: Float!
  type: String!
}

input RealmTraitListRelationFilter {
  every: RealmTraitWhereInput
  none: RealmTraitWhereInput
  some: RealmTraitWhereInput
}

enum RealmTraitType {
  City
  Harbor
  Region
  River
}

input RealmTraitWhereInput {
  AND: [RealmTraitWhereInput!]
  NOT: [RealmTraitWhereInput!]
  OR: [RealmTraitWhereInput!]
  qty: IntFilter
  realm: RealmRelationFilter
  realmId: IntFilter
  type: EnumRealmTraitTypeFilter
}

input RealmWhereInput {
  AND: [RealmWhereInput!]
  NOT: [RealmWhereInput!]
  OR: [RealmWhereInput!]
  attackTroopIds: StringNullableListFilter
  bridgedOwner: StringNullableFilter
  buildings: BuildingListRelationFilter
  defendTroopIds: StringNullableListFilter
  id: IntFilter
  imageUrl: StringFilter
  name: StringNullableFilter
  orderType: EnumOrderTypeNullableFilter
  owner: StringNullableFilter
  ownerL2: StringNullableFilter
  rarityRank: IntFilter
  rarityScore: FloatFilter
  realmId: IntFilter
  resources: ResourceListRelationFilter
  settledOwner: StringNullableFilter
  traits: RealmTraitListRelationFilter
  wallet: WalletRelationFilter
  wonder: StringNullableFilter
}

"""The Resource Model"""
type Resource {
  id: ID!
  level: Int!
  realm: Realm!
  realmId: Float
  resourceId: Int!
  upgrades: [String!]!
}

input ResourceInput {
  id: ID
  realmId: Float!
  resourceId: Int!
}

input ResourceListRelationFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

input ResourceTokenListRelationFilter {
  every: ResourceTokenWhereInput
  none: ResourceTokenWhereInput
  some: ResourceTokenWhereInput
}

input ResourceTokenWhereInput {
  AND: [ResourceTokenWhereInput!]
  NOT: [ResourceTokenWhereInput!]
  OR: [ResourceTokenWhereInput!]
  address: StringFilter
  id: IntFilter
  qty: IntFilter
  resourceId: IntFilter
  wallet: WalletRelationFilter
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  id: IntFilter
  level: IntFilter
  realm: RealmRelationFilter
  realmId: IntNullableFilter
  resourceId: IntFilter
  upgrades: StringNullableListFilter
}

input SRealmListRelationFilter {
  every: SRealmWhereInput
  none: SRealmWhereInput
  some: SRealmWhereInput
}

input SRealmWhereInput {
  AND: [SRealmWhereInput!]
  NOT: [SRealmWhereInput!]
  OR: [SRealmWhereInput!]
  id: IntFilter
  owner: StringNullableFilter
  realmId: IntFilter
  wallet: WalletRelationFilter
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""The Wallet Model"""
type Wallet {
  address: String!
  realmsBridgedHeld: Int!
  realmsL1Held: Int!
  realmsL2Held: Int!
  realmsSettledHeld: Int!
}

input WalletRelationFilter {
  is: WalletWhereInput
  isNot: WalletWhereInput
}

input WalletWhereInput {
  AND: [WalletWhereInput!]
  NOT: [WalletWhereInput!]
  OR: [WalletWhereInput!]
  address: StringFilter
  id: IntFilter
  realms: RealmListRelationFilter
  sRealms: SRealmListRelationFilter
  tokens: ResourceTokenListRelationFilter
}
